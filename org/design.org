# Local Variables
# fill-column: 80
# eval: (auto-fill-mode)
# End:
#+TITLE: Design

* Info
This document is meant to describe the design of the Smallisp Language and an
implementation of the language. To keep the document short, the document uses
terminology common to lisps, and makes no effort to explain that.

* Overview
Smallisp is a programming language designed mainly for learning purposes. It is
meant to be a lisp, and provide a minimal set of features. However, it is also
meant to have a complete and rich runtime.

* Language Design
** Syntax
   Lisp based syntax. Everything is an expression.
   - S-Expression: ( /expr/* )
     The first expression in an expression either evaluates to a function, a
     macro or a special-form.
   - Quoted List: '( /expr/* )
     Quoted lists create a list without evaluating the contents

** Evaluation
   Evaluation rule follow most lisps.
   
** Special Forms
   - def: Bind a symbol to a value
   - lambda: Create a function. => (fn (a b) /body/)
   - if: If conditional expression. => (if /pred/ /then/ /else/)
   - set!: Changes the binding of a defined symbol
** Primitive Types
   - Int: fix-width signed 64-bit integer.
   - Symbol: lisp symbol.
     Holds an object or nil.
   - List: standard lisp list. Supports fast cons and an immutable interface.
   - Function: standard function that knows how many args it should take and a
     reference to it's definition.
   - Macro: same as a function but transformed during 'macro expansion'. A
     special form is a kind of macro.
     
** Binding Rules
   *def* creates a definition and binds it to a value in the /current scope/.
   Multiple definitions cannot exists in the same scope, but they cannot exists
   in nested scopes (eg. one can create a definition in a funciton that shadows
   an outer scopes definition in a function).
   *set!* changes the binding of a variable found in the smallest scope that
   encloses to a new value.
   
* Implementation Design
** Components
   Smallisp 
*** Data Types
All Smallisp Datatypes implement the an sl::Object ABC.

#+BEGIN_SRC C++
namespace sl {

class Object {
  virtual Type GetType() = 0;
  virtual ~Object() = 0;
  virtual bool IsEqual(const Object *) const;
  virtual bool IsEqual(const Object &) const;
}

}
#+END_SRC

We do not want to have another layer of indirection for ints, to keep the
language fast and simple. 

So the definitions of sl::Int, sl::Symbol, and sl::List is as follows.
#+BEGIN_SRC C++
namespace sl {

class Int : Object {
public:
  long Value
  Int(const long &X);
  static const Int Zero = Int(0);
  static const Int One = Int(1);
}

class Symbol : Object {
public:
  std::string Name;
  Object *Object;
  // Use this for constructing symbols.
  static Symbol get(const std::string &Name) {};
}

struct Cons {
  Object *Object;
  Cons *Next;
}

class List : Object {
public:
  Cons *Head;
}

}
#+END_SRC

We would like our runtime to interact with primitive in "primitive
form". Meaning that we have minimal wrapping.

*** Reader
Instead of having a lexer and parser. I would like to implement a
LispReader. The reader would parse the input and produce Sl_List objects,
keeping the language 'list' and the implementation 'list' consistent would keep
the language smaller and also provide efficient implementations. The minor
setback would be that we have to keep the list object as simple as possible to
minimize the overhead of list objects.
*** Interpreter
**** AST Interpreter
     To provide a starter and baseline for the runtime, I would like to
     implement an AST walking interpeter. This would mean a slow but nonetheless
     working interpreter.
****  LLVM JIT Compiler
      Fitting  on a the LLVM JIT compiler would allow us to benchmark our
      bytecode interpreter implementation and JIT implementation. It would also
      serve as another execution engine.
**** Bytecode compiler and Bytecode Intpreter
     Next would be to implement a bytecode representation and a bytecode
     compiler and interpreter.
**** JIT Compiler
     Finally is a JIT compiler from bytecode to machine code.
*** Userspace vs Interpreter space
    Because this is a dynamic lisp, it is expected to have large amounts of
    overlap between userspace and interpreter space objects. However a few key
    things to note:
        - Do not leak nullptr/NULL into userspace
        - Clear distinction between interpreter coding errors and user errors
    For now, errors are a special kind of object that holds a error
    message. Functions that are exposed to userspace should signal errors with
    these error objects. This is a temporary solution before a design for
    userspace errors is concrete.
    All functions that will be called in userspace will have a return type of
    ~const Object *~ and parameter types of ~const Object *~, *NOT* specific types.
    Therefore, some level of type checking has to be done for builtin functions.
*** Using references vs pointers
    _Prefer reference over pointers_
    Ideally we have functions that take and return references in all cases.
    But that has proven to be a nuisance, because there are times we want to
    return nullptrs. But using references reduces chances of nullptr
    dereferences and provides nice value syntax on top of pointer semantics.
